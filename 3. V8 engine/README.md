V8-движок компилирует JavaScript-код в машинные инструкции в ходе исполнения программы, реализуя механизм динамической компиляции. Написан на C++.

## Структурные компоненты

Движок V8 многопоточный. Содержит

1. Главный поток, который занимается тем, что от него можно ожидать: читает исходный JS-код, компилирует его и выполняет.
2. Поток компиляции, который занимается оптимизацией кода в то время, когда выполняется главный поток.
3. Поток профилировщика, который сообщает системе о том, в каких методах программа тратит больше всего времени, как результат, Crankshaft может эти методы оптимизировать.
4. Несколько потоков, которые поддерживают механизм сборки мусора.

## Работа движка до версии 5.9 (до 2017 года)

Использовал 2 компилятора:

- full-codegen — простой и очень быстрый компилятор, который выдаёт сравнительно медленный машинный код.
- Crankshaft — более сложный оптимизирующий JIT-компилятор, который генерирует хорошо оптимизированный код.

Последовательность работы в старых версиях:

1. Запускается компилятор full-codegen, который компилирует и реализует JS код страницы.
2. В другом потоке работает поток-профилировщик, собирая информацию о путях оптимизации кода.
3. После сбора информации потоком-профилировщиком запускается поток компиляции (компилятор Crankshaft), который оптимизирует скорость выполнения кода за счет:

- встраивания кода. Встраивание кода - это подмена ссылки на функцию ссылкой на тело функции (вместо () => y встраивается return y).
- создания скрытых классов. При добавлении объекту новых свойств инициализируется создание нового скрытого класса и функция смещения при повторной инициализации свойств у другого объекта. Поэтому для оптимизации при создании различных экземпляров одного объекта следует инициализировать свойства в том же порядке - это позволит использовать смещение для поиска нужных свойств и пользоваться встроенным кэшированием.
- встроенное кэширование. Когда необходимо получить доступ к свойству объекта при выполнении метода/функции - движок обращается к скрытому классу => определяет смещение к свойству => определяет расположение свойства в буфере памяти. После 2-х успешных обращений движок кэширует расположение свойства и напрямую обращается к нему, пропуская операцию обращения к скрытому классу.

4. Перевод в низкоуровневое представление оптимизированного кода (Lithium) - компиляция в машинный код.
5. Выполняется замещение в стеке (on-stack replacement, OSR). Есть механизм защиты - деоптимизация.
6. Сборка мусора. Механизм mark-and-sweep ("пометь и выброси"), обходит Global execution contex по частям. Выполняется в отдельном потоке.

## Работа современных версий

Три основных компонента:

1. Парсер кода.
2. Компилятор и интерпретатор Ignition.
3. Оптимизированный компилятор TurboFan.
